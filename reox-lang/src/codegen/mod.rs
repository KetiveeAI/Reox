// REOX Compiler - Code Generator
// Generates C code from typed AST
// Zero external dependencies

use crate::parser::{
    Ast, Decl, Stmt, Expr, Literal, BinOp, UnaryOp, CompoundOp,
    FnDecl, StructDecl, ExternDecl, Block, Type, LetStmt,
    ReturnStmt, IfStmt, WhileStmt, ForStmt, GuardStmt, DeferStmt,
    TryCatchStmt, ThrowStmt,
};
use std::io::{self, Write};

/// Code generator state
pub struct CodeGen {
    output: String,
    indent: usize,
    defer_stack: Vec<Block>,  // Track deferred blocks for cleanup
}

impl CodeGen {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent: 0,
            defer_stack: Vec::new(),
        }
    }

    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn emit_line(&mut self, s: &str) {
        self.emit_indent();
        self.output.push_str(s);
        self.output.push('\n');
    }

    fn emit_indent(&mut self) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
    }

    fn indent(&mut self) {
        self.indent += 1;
    }

    fn dedent(&mut self) {
        if self.indent > 0 {
            self.indent -= 1;
        }
    }

    /// Generate C code from AST
    pub fn generate(&mut self, ast: &Ast) -> String {
        // Emit header
        self.emit_line("// Generated by REOX Compiler");
        self.emit_line("// Do not edit manually");
        self.emit_line("");
        self.emit_line("#include <stdio.h>");
        self.emit_line("#include <stdlib.h>");
        self.emit_line("#include <stdint.h>");
        self.emit_line("#include <stdbool.h>");
        self.emit_line("#include <string.h>");
        self.emit_line("#include \"reox_runtime.h\"");
        self.emit_line("#include \"reox_nxrender_bridge.h\"");  // NXRender integration
        self.emit_line("");

        // Forward declarations for structs
        for decl in &ast.declarations {
            if let Decl::Struct(s) = decl {
                self.emit_line(&format!("typedef struct {} {};", s.name, s.name));
            }
        }
        if ast.declarations.iter().any(|d| matches!(d, Decl::Struct(_))) {
            self.emit_line("");
        }

        // Generate struct definitions
        for decl in &ast.declarations {
            if let Decl::Struct(s) = decl {
                self.gen_struct(s);
                self.emit_line("");
            }
        }

        // Generate extern declarations
        for decl in &ast.declarations {
            if let Decl::Extern(e) = decl {
                self.gen_extern(e);
            }
        }
        if ast.declarations.iter().any(|d| matches!(d, Decl::Extern(_))) {
            self.emit_line("");
        }

        // Generate function prototypes
        for decl in &ast.declarations {
            if let Decl::Function(f) = decl {
                self.gen_fn_prototype(f);
            }
        }
        if ast.declarations.iter().any(|d| matches!(d, Decl::Function(_))) {
            self.emit_line("");
        }

        // Generate function implementations
        for decl in &ast.declarations {
            if let Decl::Function(f) = decl {
                self.gen_function(f);
                self.emit_line("");
            }
        }

        self.output.clone()
    }

    fn gen_struct(&mut self, s: &StructDecl) {
        self.emit_line(&format!("struct {} {{", s.name));
        self.indent();
        for field in &s.fields {
            let c_type = self.type_to_c(&field.ty);
            self.emit_line(&format!("{} {};", c_type, field.name));
        }
        self.dedent();
        self.emit_line("};");
    }

    fn gen_extern(&mut self, e: &ExternDecl) {
        let ret_type = e.return_type.as_ref()
            .map(|t| self.type_to_c(t))
            .unwrap_or_else(|| "void".to_string());

        let params: Vec<String> = e.params.iter()
            .map(|p| format!("{} {}", self.type_to_c(&p.ty), p.name))
            .collect();

        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };

        self.emit_line(&format!("extern {} {}({});", ret_type, e.name, params_str));
    }

    fn gen_fn_prototype(&mut self, f: &FnDecl) {
        let ret_type = f.return_type.as_ref()
            .map(|t| self.type_to_c(t))
            .unwrap_or_else(|| "void".to_string());

        let params: Vec<String> = f.params.iter()
            .map(|p| format!("{} {}", self.type_to_c(&p.ty), p.name))
            .collect();

        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };

        self.emit_line(&format!("{} {}({});", ret_type, f.name, params_str));
    }

    fn gen_function(&mut self, f: &FnDecl) {
        // Clear defer stack for new function
        self.defer_stack.clear();
        
        let ret_type = f.return_type.as_ref()
            .map(|t| self.type_to_c(t))
            .unwrap_or_else(|| "void".to_string());

        let params: Vec<String> = f.params.iter()
            .map(|p| format!("{} {}", self.type_to_c(&p.ty), p.name))
            .collect();

        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };

        self.emit_line(&format!("{} {}({}) {{", ret_type, f.name, params_str));
        self.indent();
        self.gen_block(&f.body);
        
        // Emit any remaining deferred cleanup at function end (for void functions)
        if !self.defer_stack.is_empty() {
            self.emit_deferred_cleanup();
        }
        
        self.dedent();
        self.emit_line("}");
    }

    fn gen_block(&mut self, block: &Block) {
        for stmt in &block.statements {
            self.gen_statement(stmt);
        }
    }

    fn gen_statement(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let(l) => self.gen_let(l),
            Stmt::Return(r) => self.gen_return(r),
            Stmt::If(i) => self.gen_if(i),
            Stmt::While(w) => self.gen_while(w),
            Stmt::For(f) => self.gen_for(f),
            Stmt::Expr(e) => {
                self.emit_indent();
                self.gen_expr(e);
                self.emit(";\n");
            }
            Stmt::Block(b) => {
                self.emit_line("{");
                self.indent();
                self.gen_block(b);
                self.dedent();
                self.emit_line("}");
            }
            Stmt::Break(_) => self.emit_line("break;"),
            Stmt::Continue(_) => self.emit_line("continue;"),
            // Swift/C++ style statements
            Stmt::Guard(g) => self.gen_guard(g),
            Stmt::Defer(d) => self.gen_defer(d),
            Stmt::TryCatch(t) => self.gen_try_catch(t),
            Stmt::Throw(t) => self.gen_throw(t),
        }
    }
    
    fn gen_guard(&mut self, g: &GuardStmt) {
        // guard condition else { ... }
        // Translates to: if (!(condition)) { ... }
        self.emit_indent();
        self.emit("if (!(");
        self.gen_expr(&g.condition);
        self.emit(")) {\n");
        self.indent();
        self.gen_block(&g.else_block);
        self.dedent();
        self.emit_line("}");
    }
    
    fn gen_defer(&mut self, d: &DeferStmt) {
        // Push deferred block onto stack - will be emitted before returns
        self.defer_stack.push(d.body.clone());
    }
    
    fn emit_deferred_cleanup(&mut self) {
        // Emit all deferred blocks in reverse order (LIFO)
        let blocks: Vec<Block> = self.defer_stack.iter().rev().cloned().collect();
        for block in blocks {
            self.emit_line("/* defer cleanup */");
            self.emit_line("{");
            self.indent();
            self.gen_block(&block);
            self.dedent();
            self.emit_line("}");
        }
    }
    
    fn gen_try_catch(&mut self, t: &TryCatchStmt) {
        // C doesn't have try/catch - emit as comments for now
        self.emit_line("/* try block */");
        self.emit_line("{");
        self.indent();
        self.gen_block(&t.try_block);
        self.dedent();
        self.emit_line("}");
        self.emit_line("/* catch block */");
        self.emit_line("{");
        self.indent();
        if let Some(var) = &t.catch_var {
            self.emit_line(&format!("/* error in {} */", var));
        }
        self.gen_block(&t.catch_block);
        self.dedent();
        self.emit_line("}");
    }
    
    fn gen_throw(&mut self, t: &ThrowStmt) {
        // C doesn't have throw - emit as comment + abort for now
        self.emit_indent();
        self.emit("/* throw */ abort(); /* ");
        self.gen_expr(&t.value);
        self.emit(" */\n");
    }

    fn gen_let(&mut self, l: &LetStmt) {
        let c_type = l.ty.as_ref()
            .map(|t| self.type_to_c(t))
            .unwrap_or_else(|| "auto".to_string()); // C23 auto or infer from init

        self.emit_indent();
        self.emit(&format!("{} {}", c_type, l.name));

        if let Some(init) = &l.init {
            self.emit(" = ");
            self.gen_expr(init);
        }

        self.emit(";\n");
    }

    fn gen_return(&mut self, r: &ReturnStmt) {
        // Emit deferred cleanup before return (in reverse order)
        if !self.defer_stack.is_empty() {
            self.emit_deferred_cleanup();
        }
        
        self.emit_indent();
        if let Some(value) = &r.value {
            self.emit("return ");
            self.gen_expr(value);
            self.emit(";\n");
        } else {
            self.emit("return;\n");
        }
    }

    fn gen_if(&mut self, i: &IfStmt) {
        self.emit_indent();
        self.emit("if (");
        self.gen_expr(&i.condition);
        self.emit(") {\n");
        self.indent();
        self.gen_block(&i.then_block);
        self.dedent();

        if let Some(else_block) = &i.else_block {
            self.emit_line("} else {");
            self.indent();
            self.gen_block(else_block);
            self.dedent();
        }

        self.emit_line("}");
    }

    fn gen_while(&mut self, w: &WhileStmt) {
        self.emit_indent();
        self.emit("while (");
        self.gen_expr(&w.condition);
        self.emit(") {\n");
        self.indent();
        self.gen_block(&w.body);
        self.dedent();
        self.emit_line("}");
    }

    fn gen_for(&mut self, f: &ForStmt) {
        // Convert to C-style for loop (simplified - assumes iterable is range)
        self.emit_indent();
        self.emit(&format!("for (int {} = 0; {} < ", f.var, f.var));
        self.gen_expr(&f.iterable);
        self.emit(&format!("; {}++) {{\n", f.var));
        self.indent();
        self.gen_block(&f.body);
        self.dedent();
        self.emit_line("}");
    }

    fn gen_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::Literal(lit) => self.gen_literal(lit),
            Expr::Identifier(name, _) => self.emit(name),
            Expr::Binary(left, op, right, _) => {
                self.emit("(");
                self.gen_expr(left);
                self.emit(&format!(" {} ", self.binop_to_c(op)));
                self.gen_expr(right);
                self.emit(")");
            }
            Expr::Unary(op, operand, _) => {
                self.emit(self.unaryop_to_c(op));
                self.gen_expr(operand);
            }
            Expr::Call(callee, args, _) => {
                self.gen_expr(callee);
                self.emit("(");
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_expr(arg);
                }
                self.emit(")");
            }
            Expr::Member(obj, field, _) => {
                self.gen_expr(obj);
                self.emit(&format!(".{}", field));
            }
            Expr::Index(arr, idx, _) => {
                self.gen_expr(arr);
                self.emit("[");
                self.gen_expr(idx);
                self.emit("]");
            }
            Expr::Assign(target, value, _) => {
                self.gen_expr(target);
                self.emit(" = ");
                self.gen_expr(value);
            }
            Expr::StructLit(name, fields, _) => {
                self.emit(&format!("({}){{", name));
                for (i, (field_name, value)) in fields.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.emit(&format!(".{} = ", field_name));
                    self.gen_expr(value);
                }
                self.emit("}");
            }
            Expr::ArrayLit(elements, _) => {
                self.emit("{");
                for (i, elem) in elements.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_expr(elem);
                }
                self.emit("}");
            }
            Expr::Match(scrutinee, arms, _) => {
                // Generate match as a series of if-else chains
                // For simple integer patterns, could use switch but if-else is more general
                self.emit("({\n");
                self.indent();
                
                // Store scrutinee in temporary variable
                self.emit_indent();
                self.emit("__auto_type _match_val = ");
                self.gen_expr(scrutinee);
                self.emit(";\n");
                
                // Default result variable
                self.emit_line("typeof(_match_val) _match_result = 0;");
                
                for (i, arm) in arms.iter().enumerate() {
                    self.emit_indent();
                    if i == 0 {
                        self.emit("if (");
                    } else {
                        self.emit("} else if (");
                    }
                    
                    // Generate pattern condition
                    match &arm.pattern {
                        crate::parser::Pattern::Literal(lit) => {
                            self.emit("_match_val == ");
                            self.gen_literal(lit);
                        }
                        crate::parser::Pattern::Identifier(name) => {
                            // Binding pattern - always matches
                            self.emit("1 /* bind ");
                            self.emit(name);
                            self.emit(" */");
                        }
                        crate::parser::Pattern::Wildcard => {
                            self.emit("1 /* wildcard */");
                        }
                    }
                    
                    self.emit(") {\n");
                    self.indent();
                    self.emit_indent();
                    self.emit("_match_result = ");
                    self.gen_expr(&arm.body);
                    self.emit(";\n");
                    self.dedent();
                }
                
                if !arms.is_empty() {
                    self.emit_line("}");
                }
                
                self.emit_line("_match_result;");
                self.dedent();
                self.emit_indent();
                self.emit("})");
            }
            // Swift/C++ style expressions
            Expr::CompoundAssign(target, op, value, _) => {
                self.gen_expr(target);
                self.emit(&format!(" {} ", self.compound_op_to_c(op)));
                self.gen_expr(value);
            }
            Expr::PreIncrement(operand, _) => {
                self.emit("++");
                self.gen_expr(operand);
            }
            Expr::PreDecrement(operand, _) => {
                self.emit("--");
                self.gen_expr(operand);
            }
            Expr::PostIncrement(operand, _) => {
                self.gen_expr(operand);
                self.emit("++");
            }
            Expr::PostDecrement(operand, _) => {
                self.gen_expr(operand);
                self.emit("--");
            }
            Expr::NullCoalesce(left, right, _) => {
                // C doesn't have ?? - use ternary conditional
                self.emit("((");
                self.gen_expr(left);
                self.emit(") ? (");
                self.gen_expr(left);
                self.emit(") : (");
                self.gen_expr(right);
                self.emit("))");
            }
            Expr::OptionalChain(obj, field, _) => {
                // C doesn't have ?. - emit regular member access
                self.gen_expr(obj);
                self.emit(&format!(".{}", field));
            }
            Expr::TrailingClosure(callee, body, _) => {
                // Emit callee call, then the closure body as a block
                self.gen_expr(callee);
                self.emit("; /* trailing closure: */\n");
                self.emit_line("{");
                self.indent();
                self.gen_block(body);
                self.dedent();
                self.emit_line("}");
            }
            Expr::Nil(_) => {
                self.emit("NULL");
            }
            Expr::Await(operand, _) => {
                // Emit await as rx_await() runtime call
                self.emit("rx_await(");
                self.gen_expr(operand);
                self.emit(")");
            }
        }
    }
    
    fn compound_op_to_c(&self, op: &CompoundOp) -> &'static str {
        match op {
            CompoundOp::AddEq => "+=",
            CompoundOp::SubEq => "-=",
            CompoundOp::MulEq => "*=",
            CompoundOp::DivEq => "/=",
            CompoundOp::ModEq => "%=",
        }
    }

    fn gen_literal(&mut self, lit: &Literal) {
        match lit {
            Literal::Int(n, _) => self.emit(&format!("{}", n)),
            Literal::Float(n, _) => self.emit(&format!("{:.15}", n)),
            Literal::String(s, _) => self.emit(&format!("\"{}\"", self.escape_string(s))),
            Literal::Bool(b, _) => self.emit(if *b { "true" } else { "false" }),
        }
    }

    fn escape_string(&self, s: &str) -> String {
        let mut result = String::new();
        for ch in s.chars() {
            match ch {
                '\n' => result.push_str("\\n"),
                '\t' => result.push_str("\\t"),
                '\r' => result.push_str("\\r"),
                '\\' => result.push_str("\\\\"),
                '"' => result.push_str("\\\""),
                '\0' => result.push_str("\\0"),
                _ => result.push(ch),
            }
        }
        result
    }

    fn type_to_c(&self, ty: &Type) -> String {
        match ty {
            Type::Int => "int64_t".to_string(),
            Type::Float => "double".to_string(),
            Type::String => "const char*".to_string(),
            Type::Bool => "bool".to_string(),
            Type::Void => "void".to_string(),
            Type::Named(name) => name.clone(),
            Type::Array(inner) => format!("{}*", self.type_to_c(inner)),
        }
    }

    fn binop_to_c(&self, op: &BinOp) -> &'static str {
        match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "/",
            BinOp::Mod => "%",
            BinOp::Eq => "==",
            BinOp::Ne => "!=",
            BinOp::Lt => "<",
            BinOp::Gt => ">",
            BinOp::Le => "<=",
            BinOp::Ge => ">=",
            BinOp::And => "&&",
            BinOp::Or => "||",
            BinOp::BitwiseAnd => "&",
            BinOp::BitwiseOr => "|",
            BinOp::BitwiseXor => "^",
            BinOp::ShiftLeft => "<<",
            BinOp::ShiftRight => ">>",
        }
    }

    fn unaryop_to_c(&self, op: &UnaryOp) -> &'static str {
        match op {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "!",
            UnaryOp::BitwiseNot => "~",
        }
    }
}

impl Default for CodeGen {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate C code from AST and write to file
pub fn generate(ast: &Ast, output_path: &str) -> io::Result<()> {
    let mut codegen = CodeGen::new();
    let c_code = codegen.generate(ast);

    let mut file = std::fs::File::create(output_path)?;
    file.write_all(c_code.as_bytes())?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::tokenize;
    use crate::parser::parse;

    #[test]
    fn test_simple_function() {
        let source = r#"
            fn main() {
                let x: int = 42;
                return 0;
            }
        "#;
        let tokens = tokenize(source).unwrap();
        let ast = parse(&tokens);
        let mut codegen = CodeGen::new();
        let output = codegen.generate(&ast);

        assert!(output.contains("void main(void)"));
        assert!(output.contains("int64_t x = 42"));
        assert!(output.contains("return 0"));
    }

    #[test]
    fn test_function_with_params() {
        let source = r#"
            fn add(a: int, b: int) -> int {
                return a + b;
            }
        "#;
        let tokens = tokenize(source).unwrap();
        let ast = parse(&tokens);
        let mut codegen = CodeGen::new();
        let output = codegen.generate(&ast);

        assert!(output.contains("int64_t add(int64_t a, int64_t b)"));
        assert!(output.contains("return (a + b)"));
    }

    #[test]
    fn test_struct() {
        let source = r#"
            struct Point {
                x: int,
                y: int
            }
        "#;
        let tokens = tokenize(source).unwrap();
        let ast = parse(&tokens);
        let mut codegen = CodeGen::new();
        let output = codegen.generate(&ast);

        assert!(output.contains("struct Point {"));
        assert!(output.contains("int64_t x;"));
        assert!(output.contains("int64_t y;"));
    }

    #[test]
    fn test_if_else() {
        let source = r#"
            fn check(x: int) -> int {
                if x > 0 {
                    return 1;
                } else {
                    return 0;
                }
            }
        "#;
        let tokens = tokenize(source).unwrap();
        let ast = parse(&tokens);
        let mut codegen = CodeGen::new();
        let output = codegen.generate(&ast);

        assert!(output.contains("if ((x > 0))"));
        assert!(output.contains("} else {"));
    }

    #[test]
    fn test_while_loop() {
        let source = r#"
            fn count() {
                let mut i: int = 0;
                while i < 10 {
                    i = i + 1;
                }
            }
        "#;
        let tokens = tokenize(source).unwrap();
        let ast = parse(&tokens);
        let mut codegen = CodeGen::new();
        let output = codegen.generate(&ast);

        assert!(output.contains("while ((i < 10))"));
    }
}
